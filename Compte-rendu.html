<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>quarto-input8a14b150d2c6d1e7</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="Compte-rendu_files/libs/clipboard/clipboard.min.js"></script>
<script src="Compte-rendu_files/libs/quarto-html/quarto.js"></script>
<script src="Compte-rendu_files/libs/quarto-html/popper.min.js"></script>
<script src="Compte-rendu_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Compte-rendu_files/libs/quarto-html/anchor.min.js"></script>
<link href="Compte-rendu_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Compte-rendu_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Compte-rendu_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Compte-rendu_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Compte-rendu_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
</div>
<main class="content" id="quarto-document-content">
<style>
    .page-container {
        max-width: 800px;
        margin: 0 auto;
    }
    
    /* Justification du texte - Ne s'applique PAS à la page de garde */
    body:not(.page-container) main.content p {
        text-align: justify;
    }

    /* Force le centrage pour la page de garde */
    .cover-section * {
       text-align: center !important;
    }
    
    .tp-title {
        font-size: 1.8rem;
        margin-bottom: 2rem;
    }
    
    .auteur {
        font-size: 1.4rem;
    }
    
    .date {
        font-size: 1.2rem;
        margin-bottom: 1rem;
    }
    
    .logos {
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    
    .logo-left, .logo-right {
        flex: 0 0 150px;
    }
    
    .logo-left {
        text-align: left;
    }
    
    .logo-right {
        text-align: right;
    }
    
    .logo-left img, .logo-right img {
        max-width: 150px;
        height: auto;
        transform: translateY(-50px);
    }
    
    .nom-master p {
        margin: 0.2rem 0;
        font-size: 1.1rem;
    }
    
    .ligne {
        width: 60%;
        height: 1px;
        background-color: #000;
        margin: 2rem auto 3rem auto;
    }
</style>

<div class="page-container">
    <div class="cover-section">
        <h1 class="tp-title">TP3 - Support Vector Machine (SVM)</h1>
        
        <div class="auteur">AIGOIN Emilie</div>
        <div class="date">2025-2026</div>
        
        <div class="logos">
            <div class="logo-left">
                <img src="mise_en_page/Logo_SSD.png" alt="Logo SSD">
            </div>
            
            <div class="nom-master">
                <p>Université de Montpellier</p>
                <p>Master Statistique et Science des Données</p>
            </div>
            
            <div class="logo-right">
                <img src="mise_en_page/Logo_univMtp.png" alt="Logo Université Montpellier">
            </div>
        </div>
        
        <div class="ligne"></div>
    </div>
</div>

<br><br>



<nav id="TOC" role="doc-toc">
    <h2 id="toc-title">Sommaire</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction">1. Introduction</a>
  <ul>
  <li><a href="#objectif" id="toc-objectif">1.1. Objectif</a></li>
  <li><a href="#notations-et-formules" id="toc-notations-et-formules">1.2. Notations et formules</a></li>
  <li><a href="#méthode-support-vector-machine" id="toc-méthode-support-vector-machine">1.3. Méthode Support Vector Machine</a></li>
  </ul></li>
  <li><a href="#mise-en-oeuvre---iris" id="toc-mise-en-oeuvre---iris">2. Mise en oeuvre - Iris</a>
  <ul>
  <li><a href="#question-1." id="toc-question-1.">2.1. Question 1.</a></li>
  <li><a href="#question-2.-noyau-polynomial" id="toc-question-2.-noyau-polynomial">2.2. Question 2. Noyau polynomial</a></li>
  </ul></li>
  <li><a href="#mise-en-oeuvre---svm-gui" id="toc-mise-en-oeuvre---svm-gui">3. Mise en oeuvre - SVM GUI</a>
  <ul>
  <li><a href="#question-3." id="toc-question-3.">3.1. Question 3.</a></li>
  </ul></li>
  <li><a href="#mise-en-oeuvre---classification-de-visages" id="toc-mise-en-oeuvre---classification-de-visages">4. Mise en oeuvre - Classification de visages</a>
  <ul>
  <li><a href="#question-4." id="toc-question-4.">4.1. Question 4.</a></li>
  <li><a href="#question-5." id="toc-question-5.">4.2. Question 5.</a></li>
  <li><a href="#question-6." id="toc-question-6.">4.3. Question 6.</a></li>
  <li><a href="#question-7." id="toc-question-7.">4.4. Question 7.</a></li>
  </ul></li>
  <li><a href="#conclusion" id="toc-conclusion">5. Conclusion</a></li>
  <li><a href="#sources" id="toc-sources">6. Sources</a></li>
  </ul>
</nav>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">1. Introduction</h2>
<section id="objectif" class="level3">
<h3 class="anchored" data-anchor-id="objectif">1.1. Objectif</h3>
<p>L’objectif de ce TP est de mettre en pratique la technique de classification Support Vector Machine (SVM) sur des données réelles et simulées au moyen du package <code>scikit-learn</code> et d’apprendre à contrôler les paramètres garantissant leur flexibilité.</p>
</section>
<section id="notations-et-formules" class="level3">
<h3 class="anchored" data-anchor-id="notations-et-formules">1.2. Notations et formules</h3>
<p>Nous rappelons les définitions, notations et formules suivantes :</p>
<ul>
<li><span class="math inline">\(\mathcal{Y}\)</span> : ensemble des étiquettes (labels), usuellement <span class="math inline">\(\mathcal{Y} = \{-1, 1\}\)</span> pour la classification binaire.</li>
<li><span class="math inline">\(x = (x_1, \ldots, x_p) \in \mathcal{X} \subset \mathbb{R}^p\)</span> : une observation (ou exemple) décrite par <span class="math inline">\(p\)</span> variables.</li>
<li><span class="math inline">\(\mathcal{D}_n = \{(x_i, y_i), i = 1, \ldots, n\}\)</span> : ensemble d’apprentissage contenant <span class="math inline">\(n\)</span> exemples étiquetés.</li>
<li><span class="math inline">\(\hat{f} : \mathcal{X} \to \{-1, 1\}\)</span> : fonction de classification apprise à partir de <span class="math inline">\(\mathcal{D}_n\)</span>.</li>
</ul>
<p><strong>Overfitting (surapprentissage)</strong> : phénomène où le modèle mémorise les données d’entraînement au lieu d’apprendre des patterns généralisables (problème de généralisation) et ne peut pas reconnaître d’autres données. Cela se traduit par une excellente performance sur les données d’entraînement mais une performance dégradée sur les données de test.</p>
</section>
<section id="méthode-support-vector-machine" class="level3">
<h3 class="anchored" data-anchor-id="méthode-support-vector-machine">1.3. Méthode Support Vector Machine</h3>
<p>Les Vector Support Machine (SVM) sont un ensemble de méthodes d’apprentissage supervisé, utilisées pour la classification, la régression et la détection de valeurs abberantes.</p>
<p>Les SVM reposent sur deux idées clés : la notion de marge maximale (distance entre la frontière de séparation et les échantillons les plus proches) et celle de fonction de noyau (opérateur linéaire défini à l’aide d’une intégrale paramétrique sur certains espaces fonctionnels).</p>
<p>Leurs avantages sont leur efficacité dans les espaces en grande dimension (lorsqu’il y a plus de variables que d’individus). Plusieurs fonctions de noyaux peuvent être utilisées.</p>
<p>Cependant, les SVM ne fournissent pas directement d’estimation de probabilité, il faut les calculer à l’aide de la validation croisée.</p>
</section>
</section>
<section id="mise-en-oeuvre---iris" class="level2">
<h2 class="anchored" data-anchor-id="mise-en-oeuvre---iris">2. Mise en oeuvre - Iris</h2>
<p>Nous commençons tout d’abord par importer les packages qui nous seront nécessaires pour la suite de ce TP.</p>
<div id="894691e3" class="cell" data-execution_count="1">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Importation des bibliothèques</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.svm <span class="im">import</span> SVC</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scripts_Python.svm_source <span class="im">import</span> <span class="op">*</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn <span class="im">import</span> svm</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn <span class="im">import</span> datasets</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.utils <span class="im">import</span> shuffle</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.preprocessing <span class="im">import</span> StandardScaler</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.model_selection <span class="im">import</span> train_test_split, GridSearchCV</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.datasets <span class="im">import</span> fetch_lfw_people</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.decomposition <span class="im">import</span> PCA</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> time <span class="im">import</span> time</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Initialisation du scaler pour normaliser les données</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>scaler <span class="op">=</span> StandardScaler()</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Ignorer les avertissements pour une sortie plus propre</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> warnings</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>warnings.filterwarnings(<span class="st">"ignore"</span>)</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a><span class="co"># Style de graphiques</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>plt.style.use(<span class="st">'ggplot'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<section id="question-1." class="level3">
<h3 class="anchored" data-anchor-id="question-1.">2.1. Question 1.</h3>
<p>Nous cherchons ici à développer un code qui va classifier la classe <span class="math inline">\(1\)</span> contre la classe <span class="math inline">\(2\)</span> du dataset <code>iris</code> en utilisant les deux premières variables et un noyau linéaire.</p>
<p>Pour cela, nous commençons par importer les données issues du jeu de données précédemment cité. Puis nous ne conservons que les deux premières variables.</p>
<div id="f1f806ab" class="cell" data-execution_count="2">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Chargement du dataset Iris</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>iris <span class="op">=</span> datasets.load_iris()</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> iris.data</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Normalisation des données (moyenne=0, écart-type=1)</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> scaler.fit_transform(X)</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> iris.target</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Sélection des données (que classes 1 et 2, avec les 2 premières variables)</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> X[y <span class="op">!=</span> <span class="dv">0</span>, :<span class="dv">2</span>]          <span class="co"># garde seulement les colonnes 0 et 1, exclut la classe 0</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> y[y <span class="op">!=</span> <span class="dv">0</span>]              <span class="co"># garde seulement les classes 1 et 2</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Ensuite, nous devons laisser un quart des données de côté pour évaluer la performance en généralisation du modèle. Dans ces données, nous allons les séparer en un groupe d’entraînement (<span class="math inline">\(75\%\)</span>) et un groupe de test (<span class="math inline">\(25\%\)</span>). Pour ce faire, nous avons décidé d’utiliser la fonction <code>test_train_split</code> qui permet de mélanger automatiquement les données, ce qui est important pour éviter les biais (si les données <code>iris</code> sont ordonnées par classe par exemple). Puis nous avons fixé la graine à <span class="math inline">\(42\)</span> afin d’assurer la reproductibilité.</p>
<div id="11f115c1" class="cell" data-execution_count="3">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Séparation train/test (75% train, 25% test)</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>X_train, X_test, y_train, y_test <span class="op">=</span> train_test_split(X, </span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>                                                    y, </span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>                                                    test_size <span class="op">=</span> <span class="fl">0.25</span>, </span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>                                                    random_state <span class="op">=</span> <span class="dv">42</span>) <span class="co"># graine</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Maintenant que nos données sont correctement mélangées et séparées aléatoirement, nous allons pouvoir évaluer la performance en généralisation du modèle à partir d’un . Ce noyau permet de chercher une frontière de décision linéaire (droite en <span class="math inline">\(2\)</span>D).</p>
<p>Le l’hyperparamètre <span class="math inline">\(C\)</span> que nous devons choisir (le meilleur possible) est la marge, elle doit faire un compromis entre :</p>
<ul>
<li><span class="math inline">\(C\)</span> petit : marge large mais tolère plus d’erreurs.</li>
<li><span class="math inline">\(C\)</span> grand : marge étroitre mais moins d’erreurs d’entraînement (risque d’overfitting).</li>
</ul>
<div id="2562e5b1" class="cell" data-execution_count="4">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Configuration de la recherche par grille pour trouver le meilleur C</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>parameters <span class="op">=</span> {<span class="st">'kernel'</span>: [<span class="st">'linear'</span>],               <span class="co"># noyau linéaire</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>              <span class="st">'C'</span>: <span class="bu">list</span>(np.logspace(<span class="op">-</span><span class="dv">3</span>, <span class="dv">3</span>, <span class="dv">200</span>))} <span class="co"># 200 valeurs (de 0,001 à 1000)</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Création du modèle SVM et recherche du meilleur hyperparamètre</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>svr <span class="op">=</span> svm.SVC()</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>clf_linear <span class="op">=</span> GridSearchCV(svr, parameters) <span class="co"># teste toutes les combinaisons de paramètres</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>clf_linear.fit(X_train, y_train)           <span class="co"># validation croisée</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Affichage des scores</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Generalization score for linear kernel: </span><span class="sc">%s</span><span class="st">, </span><span class="sc">%s</span><span class="st">'</span> <span class="op">%</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>      (clf_linear.score(X_train, y_train),   <span class="co"># score sur train</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>       clf_linear.score(X_test, y_test)))    <span class="co"># score sur test</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Generalization score for linear kernel: 0.7466666666666667, 0.68</code></pre>
</div>
</div>
<p>Nous savons qu’un bon modèle a un score de test proche de celui du train (ce qui veut dire qu’il n’y a pas d’overfitting).</p>
<p>Nous pouvons voir que le score pour le noyau linéaire des données d’entraînement est de <span class="math inline">\(0,75\)</span> (<span class="math inline">\(75\%\)</span>) alors que celui pour les données de test est de <span class="math inline">\(0,68\)</span> (<span class="math inline">\(68\%\)</span>).</p>
<p>La performance sur le train n’est pas excellente, en effet elle n’est que de <span class="math inline">\(75\%\)</span> ce qui indique que le modèle a un peu de mal à séparer les deux classes.</p>
<p>Cependant, le fait qu’il n’y ait qu’une diminution de <span class="math inline">\(7\%\)</span> entre les données d’entraînement et celles de test est plutôt encourageant. En effet, il est normal qu’il y ait une petite baisse sur des données qui n’ont jamais été vues.</p>
<p>Donc, comme les scores ne sont pas très élevés mais restent assez proches les uns des autres, nous pouvons en déduire que le modèle à noyau linéaire généralise moyennement. Le problème pourrait venir du fait que les classes ne se chevauchent probablement pas de manière linéaire et, comme nous utilisons un noyau linéaire, nous traçons une droite pour faire la séparation. De plus, peut être que les deux premières variables ne suffisent pas à bien discriminer les deux espèces.</p>
</section>
<section id="question-2.-noyau-polynomial" class="level3">
<h3 class="anchored" data-anchor-id="question-2.-noyau-polynomial">2.2. Question 2. Noyau polynomial</h3>
<p>Afin de comparer nos performances de généralisation du modèle entre plusieurs noyaux, nous allons faire un SVM basé sur un noyau polynomial.</p>
<div id="b2d28959" class="cell" data-execution_count="5">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Configuration des hyperparamètres pour le noyau polynomial</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>Cs <span class="op">=</span> <span class="bu">list</span>(np.logspace(<span class="op">-</span><span class="dv">3</span>, <span class="dv">3</span>, <span class="dv">5</span>)) <span class="co"># teste 5 valeurs de C (de 0.001 à 1000)</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>gammas <span class="op">=</span> <span class="fl">10.</span> <span class="op">**</span> np.arange(<span class="dv">1</span>, <span class="dv">2</span>)</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>degrees <span class="op">=</span> np.r_[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]         <span class="co"># polynômes de degrés 1, 2, 3</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Configuration de la grille de recherche</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>parameters <span class="op">=</span> {<span class="st">'kernel'</span>: [<span class="st">'poly'</span>],   <span class="co"># noyau polynomial</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>              <span class="st">'C'</span>: Cs,              <span class="co"># 5 valeurs de C</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>              <span class="st">'gamma'</span>: gammas,      <span class="co"># 1 valeur (10.0)</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>              <span class="st">'degree'</span>: degrees}    <span class="co"># 3 valeurs</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Entraînement et sélection des meilleurs hyperparamètres</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>svr_poly <span class="op">=</span> svm.SVC()                <span class="co"># vecteur vide</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>clf_poly <span class="op">=</span> GridSearchCV(svr_poly, </span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>                        parameters) <span class="co"># teste les combinaisons (validation croisée)</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>clf_poly.fit(X_train, y_train)      <span class="co"># entraine les modèles et sélectionne le meilleur</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Affichage des meilleurs paramètres trouvés</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(clf_poly.best_params_)</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Generalization score for polynomial kernel: </span><span class="sc">%s</span><span class="st">, </span><span class="sc">%s</span><span class="st">'</span> <span class="op">%</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>      (clf_poly.score(X_train, y_train),</span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>       clf_poly.score(X_test, y_test)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>{'C': np.float64(0.03162277660168379), 'degree': np.int64(1), 'gamma': np.float64(10.0), 'kernel': 'poly'}
Generalization score for polynomial kernel: 0.7466666666666667, 0.68</code></pre>
</div>
</div>
<p>Nous pouvons voir que nous obtenons exactement les mêmes scores pour le noyau polynomial que ceux que nous avions obtenu pour le noyau linéaire. En effet, nous pouvons voir des scores de <span class="math inline">\(0,75\)</span> pour le train et de <span class="math inline">\(0,68\)</span> pour les données de test.</p>
<p>Si nous regardons les hyperparamètres choisis par le modèle, nous pouvons voir que cette similarité n’est pas une coïncidence. En effet, elle s’explique par le choix des hyperparamètres optimaux sélectionnés par <code>GridSearchCV</code> pour le noyau polynomial.</p>
<p>Le paramètre important à regarder ici est le degré. Nous pouvons voir qu’il s’agit d’un noyau polynomial de degré <span class="math inline">\(1\)</span> qui a été choisi, ce qui équivaut à un noyau linéaire et c’est donc pour cela que nous obtenons les mêmes résultats au niveau des scores.</p>
<p>Ainsi, cette sélection automatique du degré <span class="math inline">\(1\)</span> par la validation croisée indique que la frontière de décision optimale pour séparer les classes <span class="math inline">\(1\)</span> et <span class="math inline">\(2\)</span> d’<code>iris</code> (avec les deux premières variables) est effectivement linéaire. Les polynômes de degrés supérieurs testés n’ont pas apporté d’amélioration, probablement car ils introduisent plus de complexité qui mène au surapprentissage sur cet ensemble de données.</p>
<p>Cela suggère que, dans l’espace défini par les deux premières variables, les données de ces deux classes d’<code>iris</code> présentent une structure essentiellement linéaire, ce qui justifie l’efficacité du noyau linéaire pour ce problème de classification.</p>
<p>Afin de vérifier ces résultats, nous allons les tracer en utilisant <code>frontiere</code>.</p>
<div id="9ffa6641" class="cell" data-execution_count="6">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Visualisation des frontières de décision (svm_source.py)</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> f_linear(xx):</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> clf_linear.predict(xx.reshape(<span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>))</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> f_poly(xx):</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> clf_poly.predict(xx.reshape(<span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>))</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Création des graphiques comparatifs</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>plt.ion()</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">15</span>, <span class="dv">5</span>))</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Graphique 1 : données originales</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>plt.subplot(<span class="dv">131</span>)</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>plot_2d(X, y)</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"iris dataset"</span>)</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Graphique 2 : frontière avec noyau linéaire</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>plt.subplot(<span class="dv">132</span>)</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>frontiere(f_linear, X, y)</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"linear kernel"</span>)</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Graphique 3 : frontière avec noyau polynomial</span></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>plt.subplot(<span class="dv">133</span>)</span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>frontiere(f_poly, X, y)</span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"polynomial kernel"</span>)</span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a>plt.draw()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Compte-rendu_files/figure-html/cell-7-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Ainsi, les graphiques confirment visuellement notre analyse précédente : les frontières de décision pour les noyaux linéaire et polynomial sont identiques.</p>
<p>Nous voyons que la frontière de décision est une droite qui sépare l’espace en deux régions distinctes (bleue et orange). La distribution des données montre qu’il n’y a pas de courbure complexe visible, ce qui justifie que les noyaux polynomiaux de degré supérieurs n’ont pas été sélectionnés.</p>
<p>De plus, nous observons un chevauchement partiel entre les deux classes (les points bleus et oranges sont mélangés dans certaines zones) ce qui explique pourquoi les scores de classification ne sont pas parfaits (<span class="math inline">\(75\%\)</span> et <span class="math inline">\(68\%\)</span>).</p>
<p><a id="part3" href=""></a></p>
</section>
</section>
<section id="mise-en-oeuvre---svm-gui" class="level2">
<h2 class="anchored" data-anchor-id="mise-en-oeuvre---svm-gui">3. Mise en oeuvre - SVM GUI</h2>
<section id="question-3." class="level3">
<h3 class="anchored" data-anchor-id="question-3.">3.1. Question 3.</h3>
<p>Dans cette question, nous nous basons sur une <a href="https://scikit-learn.org/1.2/auto_examples/applications/svm_gui.html">application</a> qui permet, en temps réel, d’évaluer l’impact du choix du noyau et du paramètre de régularisation <span class="math inline">\(C\)</span>.</p>
<p>Pour commencer, nous lançons le script <code>svm_script.py</code>. Ensuite, nous créons un dataset très déséquilibré avec <span class="math inline">\(35\)</span> points bleus (<span class="math inline">\(92\%\)</span>) et <span class="math inline">\(3\)</span> points noirs (<span class="math inline">\(8\%\)</span>) en essayant de marquer la différence entre la localisation des points bleus et noirs (tout en gardant des débordements).</p>
<div id="fig-svm" class="quarto-layout-panel">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-svm-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-layout-row">
<div class="quarto-layout-cell-subref quarto-layout-cell" data-ref-parent="fig-svm" style="flex-basis: 50.0%;justify-content: flex-start;">
<div id="fig-c10" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-subfloat-fig figure">
<div aria-describedby="fig-c10-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="graphiques/C10.png" class="img-fluid figure-img" data-ref-parent="fig-svm">
</div>
<figcaption class="quarto-float-caption-bottom quarto-subfloat-caption quarto-subfloat-fig" id="fig-c10-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
(a) C = 10
</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell-subref quarto-layout-cell" data-ref-parent="fig-svm" style="flex-basis: 50.0%;justify-content: flex-start;">
<div id="fig-c1" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-subfloat-fig figure">
<div aria-describedby="fig-c1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="graphiques/C1.png" class="img-fluid figure-img" data-ref-parent="fig-svm">
</div>
<figcaption class="quarto-float-caption-bottom quarto-subfloat-caption quarto-subfloat-fig" id="fig-c1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
(b) C = 1
</figcaption>
</figure>
</div>
</div>
</div>
<div class="quarto-layout-row">
<div class="quarto-layout-cell-subref quarto-layout-cell" data-ref-parent="fig-svm" style="flex-basis: 50.0%;justify-content: flex-start;">
<div id="fig-c01" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-subfloat-fig figure">
<div aria-describedby="fig-c01-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="graphiques/C01.png" class="img-fluid figure-img" data-ref-parent="fig-svm">
</div>
<figcaption class="quarto-float-caption-bottom quarto-subfloat-caption quarto-subfloat-fig" id="fig-c01-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
(c) C = 0,1
</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell-subref quarto-layout-cell" data-ref-parent="fig-svm" style="flex-basis: 50.0%;justify-content: flex-start;">
<div id="fig-c001" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-subfloat-fig figure">
<div aria-describedby="fig-c001-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="graphiques/C001.png" class="img-fluid figure-img" data-ref-parent="fig-svm">
</div>
<figcaption class="quarto-float-caption-bottom quarto-subfloat-caption quarto-subfloat-fig" id="fig-c001-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
(d) C = 0,01
</figcaption>
</figure>
</div>
</div>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-svm-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: Influence du paramètre C sur un dataset déséquilibré avec noyau linéaire
</figcaption>
</figure>
</div>
<p>Nous voyons dans la <a href="#fig-svm" class="quarto-xref">Figure&nbsp;1</a> que :</p>
<ul>
<li>Pour <span class="math inline">\(C = 10\)</span> : l’hyperplan est légèrement en diagonale et minimise les erreurs sur toutes les classes (les points noirs sont tous classés ensemble).</li>
<li>Pour <span class="math inline">\(C = 1\)</span> : l’hyperplan est en diagonale et fait un vrai compromis entre les deux classes. Comme celui avec <span class="math inline">\(C\)</span> plus élevé, il arrive bien à séparer à la fois les bleus et les noirs.</li>
<li>Pour <span class="math inline">\(C = 0,1\)</span> : l’hyperplan est quasiment à la verticale, il n’y a que deux points noirs qui sont ensemble et le troisième est mal classé.</li>
<li>Pour <span class="math inline">\(C = 0,01\)</span> : l’hyperplan est également à la verticale, il a l’air d’ignorer les points noirs et se contente de séparer les points bleus.</li>
</ul>
<p>Nous pouvons voir que les <span class="math inline">\(C\)</span> élevés (<span class="math inline">\(10\)</span> et <span class="math inline">\(1\)</span>) semblent proches, de même que les <span class="math inline">\(C\)</span> faibles (<span class="math inline">\(0,1\)</span> et <span class="math inline">\(0,01\)</span>). Nous voyons que les premiers prennent bien en compte les points minoritaires et les classent de la bonne manière. A contrario, les deux derniers semblent très tolérants aux erreurs : comme les bleus sont majoritaires, ils optimisent uniquement pour eux et négligent les noirs.</p>
<p>Ainsi, nous pouvons en conclure que, lorsque nous diminuons <span class="math inline">\(C\)</span> sur un dataset déséquilibré avec un noyau linéaire, l’hyperplan se déplace pour favoriser la bonne classification de la classe majoritaire et pour maximiser la marge, au détriment de la classe minoritaire. Avec <span class="math inline">\(C\)</span> très faible, le modèle ignore presque complétement les points noirs.</p>
<p>Cela s’explique car le paramètre <span class="math inline">\(C\)</span> contrôle le coût des erreurs de classification. Avec <span class="math inline">\(C\)</span> faible, le modèle préfère un hyperplan simple (avec une grande marge) quite à faire des erreurs. Sur des données déséquilibrées, ces erreurs affectent principalement la classe minoritaire car elle a moins d’influence sur l’optimisation.</p>
<p>Ce phénomène illustre donc un problème critique en apprentissage automatique sur données déséquilibrées. Lorsque <span class="math inline">\(C\)</span> diminue, le modèle privilégie une marge large (simplicité) au détriment de la précision sur la classe minoritaire.</p>
<p><a id="part4" href=""></a></p>
</section>
</section>
<section id="mise-en-oeuvre---classification-de-visages" class="level2">
<h2 class="anchored" data-anchor-id="mise-en-oeuvre---classification-de-visages">4. Mise en oeuvre - Classification de visages</h2>
<p>Dans cette partie, nous utilisons une <a href="https://scikit-learn.org/0.19/datasets/labeled_faces.html">base de données</a> extraite de “Labeled Faces in the Wild” afin d’exposer un problème de classification de visages.</p>
<p>Nous commençons donc par télécharger la base de données qui nous intéresse.</p>
<div id="24c83b7d" class="cell" data-execution_count="7">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Téléchargement de la base de données "Labeled Faces in the Wild"</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>lfw_people <span class="op">=</span> fetch_lfw_people(min_faces_per_person<span class="op">=</span><span class="dv">70</span>, resize<span class="op">=</span><span class="fl">0.4</span>,</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>                              color<span class="op">=</span><span class="va">True</span>, funneled<span class="op">=</span><span class="va">False</span>, slice_<span class="op">=</span><span class="va">None</span>,</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>                              download_if_missing<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Extraction des données</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>images <span class="op">=</span> lfw_people.images</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>n_samples, h, w, n_colors <span class="op">=</span> images.shape</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>target_names <span class="op">=</span> lfw_people.target_names.tolist()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Puis, nous choisissons une paire de personnes à classer : Donald Rumsfeld et Colin Powell.</p>
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Sélection de deux personnes à classifier</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>names <span class="op">=</span> [<span class="st">'Donald Rumsfeld'</span>, <span class="st">'Colin Powell'</span>]</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Filtrage des images pour ne garder que ces deux personnes</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>idx0 <span class="op">=</span> (lfw_people.target <span class="op">==</span> target_names.index(names[<span class="dv">0</span>]))</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>idx1 <span class="op">=</span> (lfw_people.target <span class="op">==</span> target_names.index(names[<span class="dv">1</span>]))</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>images <span class="op">=</span> np.r_[images[idx0], images[idx1]]</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>n_samples <span class="op">=</span> images.shape[<span class="dv">0</span>]</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Création des étiquettes (0 pour Rumsfeld, 1 pour Powell)</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> np.r_[np.zeros(np.<span class="bu">sum</span>(idx0)), np.ones(np.<span class="bu">sum</span>(idx1))].astype(<span class="bu">int</span>)</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Affichage d'un échantillon de 12 visages</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>plot_gallery(images, np.arange(<span class="dv">12</span>))</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div id="cell-fig-galerie" class="cell quarto-layout-panel" data-execution_count="8" data-layout-ncol="1">
<div class="quarto-layout-row">
<div class="cell-output cell-output-display quarto-layout-cell" style="flex-basis: 100.0%;justify-content: flex-start;">
<div id="fig-galerie" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-galerie-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="Compte-rendu_files/figure-html/fig-galerie-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-galerie-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2: Exemple de 12 visages de notre base de données
</figcaption>
</figure>
</div>
</div>
</div>
</div>
<p>Nous observons quelle personne entre les deux étudiées est la plus représentée dans notre jeu de données et à quelle proportion.</p>
<div id="624cd8d2" class="cell" data-execution_count="9">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Code supplémentaire de vérification/interprétation</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Vérifier la distribution des classes</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>unique, counts <span class="op">=</span> np.unique(y, return_counts<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>class_distrib <span class="op">=</span> <span class="bu">dict</span>(<span class="bu">zip</span>(unique, counts))</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Affichage des résultats</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Distribution des classes :"</span>)</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>names[<span class="dv">0</span>]<span class="sc">}</span><span class="ss"> : </span><span class="sc">{</span>class_distrib[<span class="dv">0</span>]<span class="sc">}</span><span class="ss"> images (</span><span class="sc">{</span>class_distrib[<span class="dv">0</span>]<span class="op">/</span><span class="bu">len</span>(y)<span class="op">*</span><span class="dv">100</span><span class="sc">:.1f}</span><span class="ss">%)"</span>)</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>names[<span class="dv">1</span>]<span class="sc">}</span><span class="ss"> : </span><span class="sc">{</span>class_distrib[<span class="dv">1</span>]<span class="sc">}</span><span class="ss"> images (</span><span class="sc">{</span>class_distrib[<span class="dv">1</span>]<span class="op">/</span><span class="bu">len</span>(y)<span class="op">*</span><span class="dv">100</span><span class="sc">:.1f}</span><span class="ss">%)"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Distribution des classes :
Donald Rumsfeld : 121 images (33.9%)
Colin Powell : 236 images (66.1%)</code></pre>
</div>
</div>
<p>Nous voyons qu’il y a <span class="math inline">\(357\)</span> images au total et que c’est Colin Powell qui est le plus représenté avec <span class="math inline">\(66,1\%\)</span> des images totales.</p>
<p>Nous continuons en divisant les données en deux sous-ensembles : un ensemble d’entraînement (<code>train</code>) et un ensemble de test (<code>test</code>).</p>
<div id="024535c1" class="cell" data-execution_count="10">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Extraction des caractéristiques (intensité lumineuse moyenne en niveaux de gris)</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> (np.mean(images, axis<span class="op">=</span><span class="dv">3</span>)).reshape(n_samples, <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Normalisation des caractéristiques (centrage et réduction)</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>X <span class="op">-=</span> np.mean(X, axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>X <span class="op">/=</span> np.std(X, axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Séparation train/test (50/50)</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">42</span>)     <span class="co"># ajout d'une graine pour reproductibilité</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>indices <span class="op">=</span> np.random.permutation(X.shape[<span class="dv">0</span>])</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>train_idx, test_idx <span class="op">=</span> indices[:X.shape[<span class="dv">0</span>] <span class="op">//</span> <span class="dv">2</span>], indices[X.shape[<span class="dv">0</span>] <span class="op">//</span> <span class="dv">2</span>:]</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>X_train, X_test <span class="op">=</span> X[train_idx, :], X[test_idx, :]</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>y_train, y_test <span class="op">=</span> y[train_idx], y[test_idx]</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>images_train, images_test <span class="op">=</span> images[</span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>    train_idx, :, :, :], images[test_idx, :, :, :]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<section id="question-4." class="level3">
<h3 class="anchored" data-anchor-id="question-4.">4.1. Question 4.</h3>
<p>Nous cherchons maintenant à montrer l’influence du paramètre de régularisation <span class="math inline">\(C\)</span> en affichant l’erreur de prédiction.</p>
<p><a id="fig-cOpti" href=""></a></p>
<div id="cell-fig-cOpti" class="cell" data-execution_count="11">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"--- Linear kernel ---"</span>)</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Fitting the classifier to the training set"</span>)</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>t0 <span class="op">=</span> time()</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Définition de la grille de valeurs de C à tester (de 10^-5 à 10^6)</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>Cs <span class="op">=</span> <span class="fl">10.</span> <span class="op">**</span> np.arange(<span class="op">-</span><span class="dv">5</span>, <span class="dv">6</span>)</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>scores <span class="op">=</span> []</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Boucle pour tester chaque valeur de C</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> C <span class="kw">in</span> Cs:</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Création d'un SVM avec noyau linéaire et paramètre C donné</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>    clf_temp <span class="op">=</span> svm.SVC(kernel<span class="op">=</span><span class="st">'linear'</span>, C<span class="op">=</span>C)</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Entraînement du modèle sur les données d'entraînement</span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>    clf_temp.fit(X_train, y_train)</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Évaluation sur les données de test et stockage du score</span></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>    scores.append(clf_temp.score(X_test, y_test))</span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Identification du meilleur C (celui qui maximise le score)</span></span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>ind <span class="op">=</span> np.argmax(scores)</span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Best C: </span><span class="sc">{}</span><span class="st">"</span>.<span class="bu">format</span>(Cs[ind]))</span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Visualisation de l'évolution du score en fonction de C</span></span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a>plt.figure()</span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a>plt.plot(Cs, scores)</span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Parametres de regularisation C"</span>)</span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Scores d'apprentissage"</span>)</span>
<span id="cb14-27"><a href="#cb14-27" aria-hidden="true" tabindex="-1"></a>plt.xscale(<span class="st">"log"</span>)</span>
<span id="cb14-28"><a href="#cb14-28" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb14-29"><a href="#cb14-29" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb14-30"><a href="#cb14-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-31"><a href="#cb14-31" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Best score: </span><span class="sc">{}</span><span class="st">"</span>.<span class="bu">format</span>(np.<span class="bu">max</span>(scores)))</span>
<span id="cb14-32"><a href="#cb14-32" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Predicting the people names on the testing set"</span>)</span>
<span id="cb14-33"><a href="#cb14-33" aria-hidden="true" tabindex="-1"></a>t0 <span class="op">=</span> time()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>--- Linear kernel ---
Fitting the classifier to the training set
Best C: 0.001</code></pre>
</div>
<div class="cell-output cell-output-display">
<div id="fig-copti" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-copti-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="Compte-rendu_files/figure-html/fig-copti-output-2.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-copti-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3: Evolution du score d’apprentissage en fontion du paramètre de régularisation
</figcaption>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Best score: 0.9273743016759777
Predicting the people names on the testing set</code></pre>
</div>
</div>
<p>On peut voir dans la <a href="#fig-cOpti">Figure 3</a> qu’il y a <span class="math inline">\(92,7\%\)</span> de précision sur l’ensemble de test, ce qui est une très bonne performance pour la classification de nos visages. Cela signifie que le modèle prédit correctement l’identité de la personne dans <span class="math inline">\(93\%\)</span> des cas.</p>
<p>De plus, nous voyons que la courbe montre trois zones distinctes :</p>
<ul>
<li>Pour <span class="math inline">\(C &lt; 10^{-4}\)</span> : les scores sont faibles. La régularisation est excessive, le modèle est trop simple et sous-apprend. De plus, la marge doit être trop large ce qui permet trop d’erreurs.</li>
<li>Pour <span class="math inline">\(10^{-4} ≤ C ≤ 10^{-3}\)</span> : les scores augmentent jusqu’à un pic optimal (pour <span class="math inline">\(C = 0,001\)</span>). Nous avons le meilleur compromis biais-variance car le modèle capture la structure des données sans sous ou sur apprendre.</li>
<li>Pour <span class="math inline">\(C &gt; 10^{-3}\)</span> : les scores se stabilisent en un plateau. La performance n’augmente plus car le modèle est déjà suffisamment complexe. Donc, augmenter <span class="math inline">\(C\)</span> ne sert plus à rien et nous risquons de faire apparaître du sur-apprentissage.</li>
</ul>
<p>Ainsi, le SVM avec <span class="math inline">\(C = 0.001\)</span> et le noyau linéaire offre une très bonne performance (<span class="math inline">\(92.7\%\)</span>) pour cette tâche de reconnaissance faciale : il est suffisamment élevé pour permettre au modèle de capturer les différences entre les visages mais reste assez bas pour éviter de sur-ajuster les particularités de l’ensemble d’entraînement (expressions faciales, accessoires, éclairage, etc.).</p>
<p>De plus, nous pouvons en déduire qu’il y a probablement du bruit ou des variations dans les images (éclairage, expression, etc.) ce qui permet qu’une valeur de <span class="math inline">\(C\)</span> pas trop élevée aide à ignorer ce bruit. En effet, le fait que la performance n’augmente pas pour des C plus grands suggère que le noyau linéaire capture bien la structure des données dans l’espace des caractéristiques.</p>
<p>Ainsi, à partir de ce classificateur optimal, nous cherchons maintenant à prédire les étiquettes pour les images <span class="math inline">\(X_{test}\)</span>.</p>
<div id="9e4bd38c" class="cell" data-execution_count="12">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Entraînement du modèle avec le meilleur C trouvé</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>clf <span class="op">=</span>  svm.SVC(kernel<span class="op">=</span><span class="st">'linear'</span>, C<span class="op">=</span>Cs[ind])</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>clf.fit(X_train, y_train)</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Prédiction sur l'ensemble de test</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>y_pred <span class="op">=</span> clf.predict(X_test)</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"done in </span><span class="sc">%0.3f</span><span class="st">s"</span> <span class="op">%</span> (time() <span class="op">-</span> t0))</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Calcul du niveau de chance (si on prédit toujours la classe majoritaire)</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Chance level : </span><span class="sc">%s</span><span class="st">"</span> <span class="op">%</span> <span class="bu">max</span>(np.mean(y), <span class="fl">1.</span> <span class="op">-</span> np.mean(y)))</span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Accuracy : </span><span class="sc">%s</span><span class="st">"</span> <span class="op">%</span> clf.score(X_test, y_test))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>done in 0.166s
Chance level : 0.6610644257703081
Accuracy : 0.9273743016759777</code></pre>
</div>
</div>
<p>Nous pouvons voir que nous avons un niveau de chance de <span class="math inline">\(66\%\)</span>, ce qui correspond à la précision qu’on obtiendrait en prédisant toujours la classe majoritaire (dans notre cas Colin Powell). C’est-à-dire qu’un classificateur naïf qui prédirait toujours Colin Powell aurait <span class="math inline">\(66\%\)</span> de précision. Cela correspond donc à notre borne inférieur : tout modèle doit faire mieux que ça.</p>
<p>Ensuite, nous obtenons une précision de <span class="math inline">\(92,7\%\)</span>, comme nous l’avions vu précédemment pour un <span class="math inline">\(C = 0,001\)</span>. En le comparant à notre niveau de base à absolument dépasser pour faire mieux qu’une prédiction naïve, nous voyons que la différence est très importante entre les deux. En effet, le modèle a réellement appris à distinguer les deux personnes et ne se contente pas de prédire la classe majoritaire.</p>
<p>Maintenant, après avoir évalué quantitativement nos prédictions, nous allons les évaluer qualitativement à l’aide la librairie <code>matplotlib</code>.</p>
<p><a id="fig-heatmap" href=""></a></p>
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Création des titres pour chaque prédiction (correct/incorrect)</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>prediction_titles <span class="op">=</span> [title(y_pred[i], y_test[i], names)</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>                     <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(y_pred.shape[<span class="dv">0</span>])]</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Affichage d'une galerie de prédictions</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>plot_gallery(images_test, prediction_titles)</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Visualisation des poids du classificateur sous forme d'image</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>plt.figure()</span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>plt.imshow(np.reshape(clf.coef_, (h, w)))</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div id="fig-heatmap" class="quarto-layout-panel">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-heatmap-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-layout-row">
<div class="cell-output cell-output-display quarto-layout-cell-subref quarto-layout-cell" data-ref-parent="fig-heatmap" style="flex-basis: 100.0%;justify-content: flex-start;">
<div id="fig-heatmap-1" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-subfloat-fig figure">
<div aria-describedby="fig-heatmap-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="Compte-rendu_files/figure-html/fig-heatmap-output-1.png" class="img-fluid figure-img" data-ref-parent="fig-heatmap">
</div>
<figcaption class="quarto-float-caption-bottom quarto-subfloat-caption quarto-subfloat-fig" id="fig-heatmap-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
(a) Prédiction des étiquettes des 12 premiers visages
</figcaption>
</figure>
</div>
</div>
</div>
<div class="quarto-layout-row">
<div class="cell-output cell-output-display quarto-layout-cell-subref quarto-layout-cell" data-ref-parent="fig-heatmap" style="flex-basis: 100.0%;justify-content: flex-start;">
<div id="fig-heatmap-2" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-subfloat-fig figure">
<div aria-describedby="fig-heatmap-2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="Compte-rendu_files/figure-html/fig-heatmap-output-2.png" class="img-fluid figure-img" data-ref-parent="fig-heatmap">
</div>
<figcaption class="quarto-float-caption-bottom quarto-subfloat-caption quarto-subfloat-fig" id="fig-heatmap-2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
(b) Heatmap des poids du classificateur SVM linéaire
</figcaption>
</figure>
</div>
</div>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-heatmap-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4: Évaluation qualitative des prédictions
</figcaption>
</figure>
</div>
<p>La <a href="#fig-heatmap">galerie d’images</a> permet d’évaluer visuellement les performances du modèle. On peut voir que la majorité des visages sont correctement classés (seulement <span class="math inline">\(2\)</span> erreurs sur les prédictions de Powell, ce qui correspond ici à environ <span class="math inline">\(83\%\)</span> de prédiction correcte). On voit également que le modèle a réussi à identifier les personnes même avec des variations comme les expressions faciales, les angles de vue, les conditions d’éclairage ou encore la présence/absence de lunettes.</p>
<p>La <a href="#fig-heatmap">deuxième image</a> montre une heatmap qui indique les poids du modèle SVM linéaire sous forme d’image :</p>
<ul>
<li>Les zones jaunes : elles indiquent les caractéristiques de la première classe (Colin Powell).</li>
<li>Les zones bleus foncées : elles indiquent les caractéristiques de la deuxième classe (Donald Rumself).</li>
<li>Les zones turquoise : elles indiquent que les pixels sont peu disciminants et n’aident pas à identifier la personne (poids proches de <span class="math inline">\(0\)</span>).</li>
</ul>
<p>Plus spécifiquement, nous voyons sur notre image qu’il y a des tâches jaunes principalement au centre de la photo, ce qui pourrait correspondre aux zones du nez et des yeux. De plus, nous voyons une tâche bleue foncée en dessous des jaunes, qui semble être la zone de la bouche ou du menton et qui permet d’identifier la seconde personne. Toutes ces zones décrites sont celles qui permettent le mieux d’identifier si nous sommes en présence de Colin Powell ou de Donald Rumself. Ainsi, en se basant sur le turquoise, nous pouvons voir que l’arrière plan n’aide pas à discriminer la personne dans notre modèle, ce qui est cohérent car nous avons vu qu’il changeait sur chaque photographie.</p>
<p>Ainsi, nous pouvons dire que le SVM linéaire a appris à se concentrer sur les régions centrales du visage qui contiennent effectivement le plus d’informations discriminantes. Le fait que les poids les plus élevés soient localisés et non diffus suggère que le modèle semble avoir identifié des patterns cohérents plutôt que du bruit. De plus, il nous semble distinguer un visage dans la heatmap, ce qui appuie cette dernière conclusion.</p>
</section>
<section id="question-5." class="level3">
<h3 class="anchored" data-anchor-id="question-5.">4.2. Question 5.</h3>
<p>Nous allons maintenant ajouter <span class="math inline">\(300\)</span> variables de nuisance afin de vérifier si la performance chute bien (ce qui serait dû au nombre de variables à nombre de points d’apprentissage fixé qui augmente).</p>
<div id="4c64b1e4" class="cell" data-execution_count="14">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Fonction pour entraîner et évaluer un SVM avec validation croisée</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> run_svm_cv(_X, _y):</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Ajout de la graine</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    np.random.seed(<span class="dv">42</span>)</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Permutation aléatoire des indices pour mélanger les données</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>    _indices <span class="op">=</span> np.random.permutation(_X.shape[<span class="dv">0</span>])</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Séparation en 50% train / 50% test</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>    _train_idx, _test_idx <span class="op">=</span> _indices[:_X.shape[<span class="dv">0</span>] <span class="op">//</span> <span class="dv">2</span>], _indices[_X.shape[<span class="dv">0</span>] <span class="op">//</span> <span class="dv">2</span>:]</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Extraction des sous-ensembles</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>    _X_train, _X_test <span class="op">=</span> _X[_train_idx, :], _X[_test_idx, :]</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>    _y_train, _y_test <span class="op">=</span> _y[_train_idx], _y[_test_idx]</span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Configuration de la recherche par grille (5 valeurs de C entre 0.001 et 1000)</span></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>    _parameters <span class="op">=</span> {<span class="st">'kernel'</span>: [<span class="st">'linear'</span>], <span class="st">'C'</span>: <span class="bu">list</span>(np.logspace(<span class="op">-</span><span class="dv">3</span>, <span class="dv">3</span>, <span class="dv">5</span>))}</span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>    _svr <span class="op">=</span> svm.SVC()</span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a>    _clf_linear <span class="op">=</span> GridSearchCV(_svr, _parameters)</span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Entraînement avec sélection automatique du meilleur C</span></span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a>    _clf_linear.fit(_X_train, _y_train)</span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Affichage des performances</span></span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">'Generalization score for linear kernel: </span><span class="sc">%s</span><span class="st">, </span><span class="sc">%s</span><span class="st"> </span><span class="ch">\n</span><span class="st">'</span> <span class="op">%</span></span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true" tabindex="-1"></a>          (_clf_linear.score(_X_train, _y_train), _clf_linear.score(_X_test, _y_test)))</span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-24"><a href="#cb20-24" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Score sans variable de nuisance"</span>)</span>
<span id="cb20-25"><a href="#cb20-25" aria-hidden="true" tabindex="-1"></a>run_svm_cv(X, y)</span>
<span id="cb20-26"><a href="#cb20-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-27"><a href="#cb20-27" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Score avec variable de nuisance"</span>)</span>
<span id="cb20-28"><a href="#cb20-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-29"><a href="#cb20-29" aria-hidden="true" tabindex="-1"></a><span class="co"># Nombre de caractéristiques originales</span></span>
<span id="cb20-30"><a href="#cb20-30" aria-hidden="true" tabindex="-1"></a>n_features <span class="op">=</span> X.shape[<span class="dv">1</span>]</span>
<span id="cb20-31"><a href="#cb20-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-32"><a href="#cb20-32" aria-hidden="true" tabindex="-1"></a><span class="co"># Génération de 300 variables dde nuisance (loi gaussienne)</span></span>
<span id="cb20-33"><a href="#cb20-33" aria-hidden="true" tabindex="-1"></a>sigma <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb20-34"><a href="#cb20-34" aria-hidden="true" tabindex="-1"></a>noise <span class="op">=</span> sigma <span class="op">*</span> np.random.randn(n_samples, <span class="dv">300</span>, ) </span>
<span id="cb20-35"><a href="#cb20-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-36"><a href="#cb20-36" aria-hidden="true" tabindex="-1"></a><span class="co"># Concaténation des données originales avec le bruit</span></span>
<span id="cb20-37"><a href="#cb20-37" aria-hidden="true" tabindex="-1"></a>X_noisy <span class="op">=</span> np.concatenate((X, noise), axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb20-38"><a href="#cb20-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-39"><a href="#cb20-39" aria-hidden="true" tabindex="-1"></a><span class="co"># Permutation pour mélanger les lignes</span></span>
<span id="cb20-40"><a href="#cb20-40" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">42</span>) <span class="co"># graine</span></span>
<span id="cb20-41"><a href="#cb20-41" aria-hidden="true" tabindex="-1"></a>X_noisy <span class="op">=</span> X_noisy[np.random.permutation(X.shape[<span class="dv">0</span>])]</span>
<span id="cb20-42"><a href="#cb20-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-43"><a href="#cb20-43" aria-hidden="true" tabindex="-1"></a>run_svm_cv(X_noisy, y)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Score sans variable de nuisance
Generalization score for linear kernel: 1.0, 0.9273743016759777 

Score avec variable de nuisance
Generalization score for linear kernel: 1.0, 0.6368715083798883 
</code></pre>
</div>
</div>
<p>Nous avons donc ajouté <span class="math inline">\(300\)</span> variables de nuisances générées à partir d’un bruit gaussien de variance <span class="math inline">\(\sigma = 1\)</span>. Les résultats montrent que le modèle mémorise toujours bien les données d’entraînement (<span class="math inline">\(1.0\)</span> donc <span class="math inline">\(100\%\)</span>) mais cette valeur peut indiquer un sur-apprentissage. De plus, la précision sur le test chute pour passer à <span class="math inline">\(63,7\%\)</span> ce qui cause une énorme différence entre le score de nos données de train et celle de test et montre que le modèle ne généralise plus. Enfin, nous voyons que ce modèle est moins performant que le niveau de chance, c’est-à-dire qu’il vaut mieux toujours prédire la classe majoritaire plutôt qu’utiliser ce modèle qui va se tromper plus de fois.</p>
<p>Donc, le SVM linéaire tente d’utiliser toutes les variables (signal et bruit) car il ne peut pas distinguer automatiquement les variables utiles du bruit ce qui implique que les <span class="math inline">\(300\)</span> variables de bruits noient les centaines de variables utiles. Ainsi, le ratio signal/bruit devient défavorable et conduit notre modèle à une performance inférieure au hasard.</p>
</section>
<section id="question-6." class="level3">
<h3 class="anchored" data-anchor-id="question-6.">4.3. Question 6.</h3>
<p>Afin de remédier au problème de données bruitées que nous avons observé lors de la question précédente, nous allons améliorer la prédiction à l’aide d’une méthode de réduction de dimension. Cette méthode est l’Analyse en Composantes Principales (ACP) qui projette les données dans un espace de dimension réduite.</p>
<p>Cette méthode a plusieurs avantages dans notre cas :</p>
<ul>
<li>Filtrage du bruit : les variables de nuisance sont du bruit gaussien indépendant. Comme les composantes principales capturent d’abord la structure systématique (ici les visages), le bruit se retrouve dans les composantes de faible variance et est éliminé.</li>
<li>Concentration de l’information : les <span class="math inline">\(n\)</span> premières composantes capturent un certain pourcentage de la variance totale (nous allons le voir par la suite dans le <a href="#tableau">tableau récapitulatif</a>). Cette variance correspond principalement aux vraies caractéristiques faciales. Ainsi, on passe de plus de <span class="math inline">\(400\)</span> dimension à <span class="math inline">\(20\)</span>, donc le ratio entre le signal et le bruit est nettement amélioré.</li>
</ul>
<p>Nous testons différentes valeurs de <span class="math inline">\(n\)</span> (nombre de composantes) pour pouvoir les comparer entre elles et identifier le nombre optimal de composantes principales. Le choix de <span class="math inline">\(n\)</span> est très important et nous allons essayer de voir son ordre de grandeur optimal :</p>
<ul>
<li>Trop peu de composants entraîne une perte de signal utile.</li>
<li>Trop de composantes et nous conservons du bruit.</li>
</ul>
<p>Nous avons écrit le code suivant pour <span class="math inline">\(n = 20\)</span> et l’avons ensuite modifié en changeant juste ce paramètre.</p>
<div id="0fb69888" class="cell" data-execution_count="15">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="co">""" # Décommenter le code pour le faire tourner (attention, environ 20 minutes de chargement)</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="co">print("Score apres reduction de dimension")</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Nombre de composantes principales à conserver</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a><span class="co">n_components = 20  # jouer avec ce parametre</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Création et ajustement du modèle ACP sur les données bruitées</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a><span class="co">pca = PCA(n_components=n_components, random_state=42).fit(X_noisy)</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Projection des données dans le nouvel espace réduit</span></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a><span class="co">X_noisy_pca = pca.transform(X_noisy)</span></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Évaluation du modèle sur les données transformées</span></span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a><span class="co">run_svm_cv(X_noisy_pca, y) """</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="15">
<pre><code>' # Décommenter le code pour le faire tourner (attention, environ 20 minutes de chargement)\n\nprint("Score apres reduction de dimension")\n\n# Nombre de composantes principales à conserver\nn_components = 20  # jouer avec ce parametre\n\n# Création et ajustement du modèle ACP sur les données bruitées\npca = PCA(n_components=n_components, random_state=42).fit(X_noisy)\n\n# Projection des données dans le nouvel espace réduit\nX_noisy_pca = pca.transform(X_noisy)\n\n# Évaluation du modèle sur les données transformées\nrun_svm_cv(X_noisy_pca, y) '</code></pre>
</div>
</div>
<p>Nous avons obtenu les scores suivants :</p>
<p><a id="tableau" href=""></a></p>
<div id="tbl-pca" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-pca-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;1: Impact du nombre de composantes de l’ACP sur les scores du modèle de classification
</figcaption>
<div aria-describedby="tbl-pca-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="caption-top table">
<thead>
<tr class="header">
<th style="text-align: center;">Nombre de composantes</th>
<th style="text-align: center;">Score Train</th>
<th style="text-align: center;">Score Test</th>
<th style="text-align: center;">Écart</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">2</td>
<td style="text-align: center;">0,691</td>
<td style="text-align: center;">0,631</td>
<td style="text-align: center;">6,0%</td>
</tr>
<tr class="even">
<td style="text-align: center;">5</td>
<td style="text-align: center;">0,663</td>
<td style="text-align: center;">0,659</td>
<td style="text-align: center;">0,4%</td>
</tr>
<tr class="odd">
<td style="text-align: center;">10</td>
<td style="text-align: center;">0,646</td>
<td style="text-align: center;">0,665</td>
<td style="text-align: center;">1,9%</td>
</tr>
<tr class="even">
<td style="text-align: center;">15</td>
<td style="text-align: center;">0,691</td>
<td style="text-align: center;">0,631</td>
<td style="text-align: center;">6,0%</td>
</tr>
<tr class="odd">
<td style="text-align: center;">20</td>
<td style="text-align: center;">0,646</td>
<td style="text-align: center;">0,642</td>
<td style="text-align: center;">0,4%</td>
</tr>
<tr class="even">
<td style="text-align: center;">25</td>
<td style="text-align: center;">0,697</td>
<td style="text-align: center;">0,631</td>
<td style="text-align: center;">6,6%</td>
</tr>
<tr class="odd">
<td style="text-align: center;">30</td>
<td style="text-align: center;">0,691</td>
<td style="text-align: center;">0,603</td>
<td style="text-align: center;">8,8%</td>
</tr>
<tr class="even">
<td style="text-align: center;">50</td>
<td style="text-align: center;">0,770</td>
<td style="text-align: center;">0,536</td>
<td style="text-align: center;">23,4%</td>
</tr>
<tr class="odd">
<td style="text-align: center;">100</td>
<td style="text-align: center;">0,888</td>
<td style="text-align: center;">0,542</td>
<td style="text-align: center;">34,6%</td>
</tr>
<tr class="even">
<td style="text-align: center;">200</td>
<td style="text-align: center;">0,966</td>
<td style="text-align: center;">0,542</td>
<td style="text-align: center;">42,1%</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p>Afin d’identifier le nombre optimal de composantes principales et de déterminer le seuil à partir duquel apparaît l’overfitting, nous avons testé une large gamme de valeurs : <span class="math inline">\(n = 2, 5, 10, 15, 20, 25, 30, 50, 100, 200\)</span>. Cette exploration systématique nous permet d’observer l’évolution des performances et de caractériser précisément le comportement du modèle en fonction de la dimensionnalité.</p>
<p>Au niveau du lancement du code, le temps de calcul s’est révélé particulièrement long pour cette expérimentation. L’exécution complète a nécessité environ <span class="math inline">\(20\)</span> minutes pour chaque les valeurs de <span class="math inline">\(n\)</span> testées, à l’exception de <span class="math inline">\(n=100\)</span> et <span class="math inline">\(n=200\)</span> qui ont été nettement plus rapides (<span class="math inline">\(5\)</span> secondes). Cette différence s’explique par le fait que pour <span class="math inline">\(n=100\)</span> et <span class="math inline">\(n=200\)</span>, bien que le nombre de composante soit plus élevé, l’algorithme converge plus rapidement car les données deviennent linéairement séparables dans cet espace de grande dimension (au prix d’un overfitting massif).</p>
<p>A partir de ce tableau, un premier élément particulièrement anormal attire notre attention : le score d’entraînement ne croît pas de manière monotone avec le nombre de composantes. En théorie, lorsque nous augmentons le nombre de composantes, nous donnons au modèle plus d’informations pour ajuster les données d’entraînement. Le score <code>train</code> devrait donc augmenter (ou du moins rester constant) mais jamais diminuer. Or, nous observons des scores de <span class="math inline">\(69,1\%\)</span> pour <span class="math inline">\(n = 2\)</span>, puis <span class="math inline">\(64,6\%\)</span> pour <span class="math inline">\(n = 10\)</span>, avant de remonter à <span class="math inline">\(77,0\%\)</span> pour <span class="math inline">\(n = 50\)</span>. Cette non-monotonie est anormale.</p>
<p>Une explication potentielle pourrait venir d’un problème méthodologique. En effet, la fonction <code>run_svm_cv</code> effectue systématiquement un nouveau split aléatoire des données à chaque appel via <code>np.random.permutation(X.shape[0])</code>. Ainsi, chaque valeur de <span class="math inline">\(n\)</span> est évaluée sur un ensemble d’entraînement différent, ce qui introduit de la variabilité aléatoire et empêche toute comparaison rigoureuse. Même si le code fourni permet de fixer une graine aléatoire avant l’appel à <code>run_svm_cv</code>, rendant possible la reproductibilité pour chaque <span class="math inline">\(n\)</span>, la comparaison directe entre les différentes valeurs de <span class="math inline">\(n\)</span> n’est pas vraiment possible car l’aléatoire diffère entre chaque valeur. Cette instabilité méthodologique explique les fluctuations observées sur le <code>train</code>.</p>
<p>Concernant le score de <code>test</code>, nous observons une tendance plus claire : les performances augmentent légèrement jusqu’à <span class="math inline">\(n = 10\)</span> composantes où nous atteignons <span class="math inline">\(66,5\%\)</span>, puis diminuent progressivement pour stagner autour de <span class="math inline">\(54\%\)</span> pour <span class="math inline">\(n≥50\)</span>. Le meilleur compromis semble donc se situer autour de <span class="math inline">\(n=10\)</span> composantes. Cependant, même ce “meilleur” résultat reste décevant avec seulement <span class="math inline">\(66,5\%\)</span> de précision, à peine au-dessus du niveau de chance (<span class="math inline">\(66\%\)</span>). Cela suggère que les <span class="math inline">\(300\)</span> variables de nuisance ont tellement dégradé le signal que même avec une réduction de dimension optimale, nous ne parvenons pas à retrouver les performances initiales (<span class="math inline">\(~92\%\)</span>).</p>
<p>Enfin, l’écart entre <code>train</code> et <code>test</code> révèle un phénomène critique : pour <span class="math inline">\(n≤20\)</span> composantes, l’écart reste faible (entre <span class="math inline">\(0,4\%\)</span> et <span class="math inline">\(8,8\%\)</span>), indiquant que le modèle généralise correctement. En revanche, au-delà de <span class="math inline">\(n=20\)</span>, l’écart explose littéralement : <span class="math inline">\(23,4\%\)</span> pour <span class="math inline">\(n=50\)</span>, <span class="math inline">\(34,6\%\)</span> pour <span class="math inline">\(n=100\)</span>, et <span class="math inline">\(42,4\%\)</span> pour <span class="math inline">\(n=200\)</span>. Ce phénomène d’overfitting massif s’explique par le fait que les composantes principales de rang élevé ne capturent plus du signal discriminant mais principalement du bruit structuré. Le modèle mémorise ces patterns bruités sur l’ensemble d’entraînement (d’où le score <code>train</code> atteignant <span class="math inline">\(96,6\%\)</span> pour <span class="math inline">\(n=200\)</span>), mais ces patterns artificiels ne se généralisent absolument pas au test (qui stagne à <span class="math inline">\(54\%\)</span>). Ainsi, augmenter le nombre de composantes au-delà de <span class="math inline">\(20\)</span> ne fait qu’amplifier le sur-apprentissage sans apporter aucun gain en généralisation.</p>
<p>Ce résultat illustre un principe important en machine learning : plus de variables n’est pas toujours mieux (overfitting).</p>
</section>
<section id="question-7." class="level3">
<h3 class="anchored" data-anchor-id="question-7.">4.4. Question 7.</h3>
<p>Il existe un biais dans notre prétraitement des données. En effet, au niveau de la question 4, la standardisation est effectuée sur l’ensemble complet des données avant la séparation en un échantillon d’entraînement et un autre de test. Donc, cela pose problème car les statistiques (moyenne et écart-type) sont calculées en incluant les données de test. Ainsi, le modèle a indirectement accès à des informations de l’échantillon de test pendant l’entraînement, ce qui crée une fuite d’information. Donc, les performances mesurées sont surestimées car le modèle bénéficie d’informations qu’il ne devrait pas avoir en situation réelle. Cela peut également avoir un impact sur l’ACP qui en découle.</p>
<p>La bonne pratique serait de standardiser en utilisant uniquement les données et statistiques associées de l’échantillon d’entraînement.</p>
<p>De plus, comme nous l’avons vu juste au-dessus, il existe un biais au niveau de la permutation, ce qui complique la comparaison des scores et leur interprétation.</p>
</section>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">5. Conclusion</h2>
<p>Au cours de ce TP, nous avons exploré la méthode des Support Vector Machines (SVM) à travers trois applications progressives.</p>
<p>Sur le jeu de données <code>iris</code>, la comparaison des noyaux linéaire et polynomial a révélé que la structure des données est essentiellement linéaire, avec des scores de <span class="math inline">\(75\%\)</span> en entraînement et <span class="math inline">\(68\%\)</span> en test indiquant une généralisation correcte mais moyenne. L’exploration avec <code>svm_gui.py</code> a ensuite démontré l’impact critique du paramètre <span class="math inline">\(C\)</span> sur données déséquilibrées : avec <span class="math inline">\(C\)</span> faible, l’hyperplan privilégie systématiquement la classe majoritaire, négligeant la classe minoritaire.</p>
<p>Nous avons ensuite fait une application basée sur la reconnaissance faciale. Avec un noyau linéaire optimal (<span class="math inline">\(C = 0.001\)</span>), nous avons atteint <span class="math inline">\(92,7\%\)</span> de précision, bien au-dessus du niveau de chance (<span class="math inline">\(66\%\)</span>). La visualisation des poids a confirmé que le modèle se focalise correctement sur les régions discriminantes (yeux, nez, bouche). Cependant, l’ajout de <span class="math inline">\(300\)</span> variables de nuisance a provoqué une chute à <span class="math inline">\(63,7\%\)</span>, démontrant la vulnérabilité des SVM face au bruit. L’ACP a partiellement résolu ce problème avec un optimum à <span class="math inline">\(n=10\)</span> composantes (<span class="math inline">\(66,5\%\)</span>), mais au-delà de <span class="math inline">\(n=20\)</span>, nous avons observé un overfitting massif confirmant qu’un nombre excessif de variables conduit au sur-apprentissage.</p>
<p>Ce TP a également révélé des limites méthodologiques importantes : la standardisation avant séparation train/test crée une fuite d’information surestimant les performances et les permutations aléatoires successives compliquent la comparaison rigoureuse entre configurations.</p>
<p>En conclusion, la présence de bruit peut dégrader de façon importante les performances, ce qui souligne l’importance de techniques comme l’ACP pour filtrer les variables non informatives. Plus généralement, ce travail rappelle qu’augmenter la complexité d’un modèle n’améliore pas nécessairement ses performances et que la validation méthodologique rigoureuse reste essentielle pour garantir des résultats fiables et généralisables.</p>
</section>
<section id="sources" class="level2">
<h2 class="anchored" data-anchor-id="sources">6. Sources</h2>
<p>Afin de réaliser ce TP, nous nous sommes basés sur plusieurs sources. Tout d’abord, nous avons utilisé la base de code donnée par B.Bensaid, B. Charlier et J. Salmon. De plus, nous avons utilisé le fichier définissant des fonctions <code>svm_source.py</code> écrit par J. Salmon, A. Gramfort et C. Vernade.</p>
<p>Ensuite, afin de réaliser la <a href="#part3">partie 3</a>, nous nous sommes servis du code disponible via <a href="https://scikit-learn.org/1.2/auto_examples/applications/svm_gui.html">ce lien</a> et écrit par P. Prettenhoer. En ce qui concerne la <a href="#part4">partie 4</a>, nous nous sommes servis de la base de données disponible via <a href="https://scikit-learn.org/0.19/datasets/labeled_faces.html">ce lien</a>.</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>